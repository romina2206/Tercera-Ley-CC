<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>3ª Ley: Choque Elástico (Riguroso)</title>
<style>
  body { margin: 0; font-family: 'Segoe UI', sans-serif; background: #f7f7f7; overflow: hidden; }
  
  #ui-container {
    position: absolute; top: 20px; left: 20px; z-index: 10;
    display: flex; flex-direction: column; gap: 10px; width: 300px;
  }

  .ui-panel {
    background: rgba(255, 255, 255, 0.95); padding: 15px;
    border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.1);
  }

  h2 { margin: 0 0 10px 0; color: #5A2382; font-size: 18px; }
  label { display: block; font-weight: bold; margin-bottom: 5px; font-size: 14px; }
  input[type=range] { width: 100%; cursor: pointer; margin-bottom: 10px; }
  
  .val-display { float: right; font-weight: bold; }
  .rojo { color: #D32F2F; }
  .azul { color: #1976D2; }

  button {
    width: 100%; padding: 12px; background: #E6500F; color: white;
    border: none; border-radius: 6px; font-size: 16px; cursor: pointer; font-weight: bold;
    margin-top: 10px;
  }
  button:hover { background: #c9420a; }

  #collision-status {
      text-align: center; font-weight: bold; margin-top: 10px; min-height: 20px;
  }
  
  .friction-control {
      margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd;
  }
</style>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>
</head>

<body>

<div id="ui-container">
  
  <div class="ui-panel">
    <h2>3ª Ley: Choque Elástico</h2>
    
    <label class="rojo">Masa A (Atacante) <span id="val-mass-a" class="val-display">1 kg</span></label>
    <input type="range" id="slider-mass-a" min="1" max="10" step="1" value="1">

    <label class="azul">Masa B (Objetivo) <span id="val-mass-b" class="val-display">1 kg</span></label>
    <input type="range" id="slider-mass-b" min="1" max="10" step="1" value="1">
    
    <label>Velocidad Inicial A</label>
    <input type="range" id="slider-vel" min="10" max="50" value="20">

    <div class="friction-control">
        <label style="display:flex; align-items:center; cursor:pointer;">
            <input type="checkbox" id="check-friction" style="width:20px; margin-right:10px;">
            Activar Rozamiento
        </label>
        <div style="font-size:11px; color:#666; margin-left:30px;">
            (Si no se activa, se deslizan infinitamente)
        </div>
    </div>

    <button id="btn-lanzar">¡Lanzar!</button>
  </div>

  <div class="ui-panel">
    <div id="collision-status">Listo</div>
    <div style="margin-top:10px; font-size:12px;">
       <div>Velocidad A: <span id="vel-a-disp">0.00</span> m/s</div>
       <div>Velocidad B: <span id="vel-b-disp">0.00</span> m/s</div>
    </div>
  </div>

</div>

<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

  let scene, camera, renderer, controls;
  let cubeA, cubeB;
  let arrowForceA, arrowForceB; 
  
  // Física
  let massA = 1;
  let massB = 1;
  let velA = 0;
  let velB = 0;
  let initVelA = 0.2;
  
  let isSimulating = false;
  let hasCollided = false;

  // DOM
  const sliderMassA = document.getElementById('slider-mass-a');
  const sliderMassB = document.getElementById('slider-mass-b');
  const sliderVel = document.getElementById('slider-vel');
  const statusDiv = document.getElementById('collision-status');
  const checkFriction = document.getElementById('check-friction');

  init();
  animate();

  function init() {
    // 1. Scene Setup
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0xf0f0f0);
    
    // Cámara más amplia
    camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 200);
    camera.position.set(0, 15, 30); 
    camera.lookAt(0, 0, 0);
    
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    controls = new OrbitControls(camera, renderer.domElement);
    // Limitamos el zoom para no perderse
    controls.minDistance = 10;
    controls.maxDistance = 100;

    // Luces
    scene.add(new THREE.AmbientLight(0xffffff, 0.6));
    const light = new THREE.DirectionalLight(0xffffff, 0.8);
    light.position.set(5, 10, 5);
    scene.add(light);

    // Piso MUY largo (Pista de hielo infinita)
    const floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 40), new THREE.MeshStandardMaterial({ color: 0xcccccc }));
    floor.rotation.x = -Math.PI / 2;
    floor.position.y = -0.5;
    scene.add(floor);
    scene.add(new THREE.GridHelper(200, 40));

    // Cubos (Asegurándonos de agregarlos a la escena)
    cubeA = createCube(0xD32F2F); // Rojo
    cubeB = createCube(0x1976D2); // Azul

    // Flechas de vector fuerza (Acción/Reacción)
    arrowForceA = new THREE.ArrowHelper(new THREE.Vector3(-1,0,0), new THREE.Vector3(0,0,0), 3, 0xD32F2F, 1, 0.6);
    arrowForceB = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 3, 0x1976D2, 1, 0.6);
    arrowForceA.visible = false;
    arrowForceB.visible = false;
    scene.add(arrowForceA);
    scene.add(arrowForceB);

    // Event Listeners
    sliderMassA.addEventListener('input', updateParams);
    sliderMassB.addEventListener('input', updateParams);
    sliderVel.addEventListener('input', updateParams);
    document.getElementById('btn-lanzar').addEventListener('click', startSimulation);
    window.addEventListener("resize", onResize);

    resetPositions();
  }

  function createCube(color) {
    const mesh = new THREE.Mesh(
      new THREE.BoxGeometry(1, 1, 1),
      new THREE.MeshStandardMaterial({ color: color })
    );
    scene.add(mesh);
    return mesh;
  }

  function updateParams() {
    massA = parseFloat(sliderMassA.value);
    massB = parseFloat(sliderMassB.value);
    initVelA = parseFloat(sliderVel.value) / 100; 

    document.getElementById('val-mass-a').innerText = massA + " kg";
    document.getElementById('val-mass-b').innerText = massB + " kg";

    const sA = 0.8 + (massA * 0.15);
    const sB = 0.8 + (massB * 0.15);
    
    cubeA.scale.set(sA, sA, sA);
    cubeB.scale.set(sB, sB, sB);
    
    if(!isSimulating) {
        cubeA.position.y = (sA/2) - 0.5;
        cubeB.position.y = (sB/2) - 0.5;
    }
  }

  function resetPositions() {
    isSimulating = false;
    hasCollided = false;
    velA = 0;
    velB = 0;
    arrowForceA.visible = false;
    arrowForceB.visible = false;
    
    cubeA.position.set(-10, cubeA.position.y, 0); 
    cubeB.position.set(0, cubeB.position.y, 0);  
    
    statusDiv.innerText = "Listo para lanzar";
    statusDiv.style.color = "black";
    
    // Resetear cámara
    controls.target.set(0,0,0);
    camera.position.set(0, 15, 30);
  }

  function startSimulation() {
    resetPositions(); // Resetear primero para asegurar posición inicial
    isSimulating = true;
    velA = initVelA; 
    velB = 0;        
    statusDiv.innerText = "¡Moviéndose!";
  }

  function resolveCollision() {
    hasCollided = true;
    statusDiv.innerText = "¡IMPACTO!";
    statusDiv.style.color = "#E6500F";

    // Visualizar fuerzas
    const contactX = (cubeA.position.x + cubeB.position.x) / 2;
    const contactY = Math.max(cubeA.scale.y, cubeB.scale.y) + 1;
    
    arrowForceA.position.set(contactX, contactY, 0);
    arrowForceB.position.set(contactX, contactY, 0);
    arrowForceA.visible = true;
    arrowForceB.visible = true;

    // --- FÍSICA PURA: Choque Elástico Perfecto ---
    const vA = velA;
    const vB = velB;

    // Fórmulas de conservación de momento lineal y energía cinética
    velA = ((massA - massB) * vA + 2 * massB * vB) / (massA + massB);
    velB = ((massB - massA) * vB + 2 * massA * vA) / (massA + massB);

    setTimeout(() => {
        arrowForceA.visible = false;
        arrowForceB.visible = false;
    }, 500);
  }

  function applyFriction() {
    // Solo si el checkbox está marcado
    if (!checkFriction.checked) return;

    // Fricción constante (mu * g). Resta lineal a la velocidad
    const friction = 0.002;

    if (velA > 0) velA = Math.max(0, velA - friction);
    else if (velA < 0) velA = Math.min(0, velA + friction);

    if (velB > 0) velB = Math.max(0, velB - friction);
    else if (velB < 0) velB = Math.min(0, velB + friction);
  }

  function animate() {
    requestAnimationFrame(animate);

    if (isSimulating) {
        // Mover
        cubeA.position.x += velA;
        cubeB.position.x += velB;

        // Detectar Colisión
        const minDist = (cubeA.scale.x / 2) + (cubeB.scale.x / 2);
        const dist = cubeB.position.x - cubeA.position.x;

        if (dist <= minDist && !hasCollided) {
            resolveCollision();
            // Evitar solapamiento
            const overlap = minDist - dist;
            cubeA.position.x -= overlap / 2;
            cubeB.position.x += overlap / 2;
        }

        // Aplicar Rozamiento (Solo si el usuario lo pide)
        // Antes esto era automático, ahora es opcional.
        if (hasCollided || isSimulating) {
            applyFriction();
        }

        // Actualizar UI
        document.getElementById('vel-a-disp').innerText = velA.toFixed(2);
        document.getElementById('vel-b-disp').innerText = velB.toFixed(2);
        
        // Seguimiento suave de cámara si se van muy lejos
        if(Math.abs(cubeB.position.x) > 15 || Math.abs(cubeA.position.x) > 15) {
             const targetX = (cubeA.position.x + cubeB.position.x) / 2;
             controls.target.x += (targetX - controls.target.x) * 0.05;
        }
    }

    controls.update();
    renderer.render(scene, camera);
  }

  function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  }
</script>

</body>
</html>
